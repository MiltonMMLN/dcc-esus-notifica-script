# =========================
# Script 2.5 — DCC × DCA (SINAN/DATASUS)
# Seleção via janelas (abrir/salvar) e exportação XLSX/CSV
# =========================

# --- 1) Pacotes ---
pacotes <- c(
  "dplyr", "readr", "stringr", "lubridate", "openxlsx",
  "stringdist", "stringi", "purrr", "svDialogs"
)
novos <- pacotes[!(pacotes %in% installed.packages()[, "Package"])]
if (length(novos)) install.packages(novos, dependencies = TRUE)
invisible(lapply(pacotes, library, character.only = TRUE))

# --- 2) Parâmetros (limiares de similaridade) ---
LIMIAR_SIMILARIDADE     <- 0.95  # Jaro-Winkler mínimo p/ nome do paciente
LIMIAR_SIMILARIDADE_MAE <- 0.95  # Jaro-Winkler mínimo p/ nome da mãe (quando disponível)

# --- 3) Seleção de ARQUIVOS (CSV, UTF-8, ;) e SAÍDAS ---
message("Selecione o ARQUIVO DCC (CSV; UTF-8 BOM; ;)")
arq_dcc <- svDialogs::dlgOpen(title = "Abrir DCC (CSV; UTF-8 BOM; ;)")$res
if (is.null(arq_dcc) || arq_dcc == "") stop("Operação cancelada: DCC não selecionado.")

message("Selecione o ARQUIVO DCA (CSV; UTF-8 BOM; ;)")
arq_dca <- svDialogs::dlgOpen(title = "Abrir DCA (CSV; UTF-8 BOM; ;)")$res
if (is.null(arq_dca) || arq_dca == "") stop("Operação cancelada: DCA não selecionado.")

# sugestão de nomes de saída no mesmo diretório do DCC
dir_base <- dirname(arq_dcc)
xlsx_sug <- file.path(dir_base, "possiveis_duplicadas_DCC_vs_DCA.xlsx")
csv_sug  <- file.path(dir_base, "possiveis_duplicadas_DCC_vs_DCA.csv")

message("Escolha ONDE salvar a SAÍDA em XLSX...")
arq_xlsx <- svDialogs::dlgSave(title = "Salvar resultado (.xlsx)", default = xlsx_sug)$res
if (is.null(arq_xlsx) || arq_xlsx == "") stop("Operação cancelada: saída XLSX não informada.")
if (!grepl("\\.xlsx$", tolower(arq_xlsx))) arq_xlsx <- paste0(arq_xlsx, ".xlsx")

message("Escolha ONDE salvar a SAÍDA em CSV...")
arq_csv <- svDialogs::dlgSave(title = "Salvar resultado (.csv)", default = csv_sug)$res
if (is.null(arq_csv) || arq_csv == "") stop("Operação cancelada: saída CSV não informada.")
if (!grepl("\\.csv$", tolower(arq_csv))) arq_csv <- paste0(arq_csv, ".csv")

# --- 4) Leitura padronizada ---
ler_csv_padrao <- function(caminho) {
  readr::read_delim(
    caminho,
    delim = ";",
    locale = readr::locale(encoding = "UTF-8"),
    show_col_types = FALSE,
    trim_ws = TRUE
  )
}

dcc_raw <- ler_csv_padrao(arq_dcc)
dca_raw <- ler_csv_padrao(arq_dca)

# --- 5) Funções auxiliares ---
normaliza_nome <- function(x) {
  if (all(is.na(x))) return(x)
  x %>%
    stringr::str_replace_all("[^\\p{L} ]+", " ") %>%
    stringr::str_squish() %>%
    stringi::stri_trans_general("Latin-ASCII") %>%
    stringr::str_to_lower()
}

parse_data_segura <- function(x) suppressWarnings(lubridate::dmy(x))
sim_jw <- function(a, b) ifelse(is.na(a) | is.na(b), NA_real_, stringdist::stringsim(a, b, method = "jw"))
fmt_date <- function(x) ifelse(is.na(x), NA_character_, format(x, "%d/%m/%Y"))

# --- 6) Checagem de colunas obrigatórias ---
campos_req <- c("NM_PACIENT", "DT_NASC", "DT_NOTIFIC", "NU_NOTIFIC")
faltam_dcc <- setdiff(campos_req, names(dcc_raw))
faltam_dca <- setdiff(campos_req, names(dca_raw))
if (length(faltam_dcc) > 0) stop("No DCC faltam: ", paste(faltam_dcc, collapse = ", "))
if (length(faltam_dca) > 0) stop("No DCA faltam: ", paste(faltam_dca, collapse = ", "))

# --- 7) Preparação dos bancos ---
tem_SG_UF_dcc      <- "SG_UF"       %in% names(dcc_raw)
tem_CD_MN_RESI_dcc <- "CD_MN_RESI"  %in% names(dcc_raw)  # DCC usa CD_MN_RESI
tem_NM_MAE_dcc     <- "NM_MAE_PAC"  %in% names(dcc_raw)

tem_SG_UF_dca      <- "SG_UF"       %in% names(dca_raw)
tem_ID_MN_RESI_dca <- "ID_MN_RESI"  %in% names(dca_raw)  # DCA mantém ID_MN_RESI
tem_NM_MAE_dca     <- "NM_MAE_PAC"  %in% names(dca_raw)

dcc <- dcc_raw %>%
  dplyr::mutate(
    NM_PACIENT_norm = normaliza_nome(NM_PACIENT),
    NM_MAE_norm     = if (tem_NM_MAE_dcc) normaliza_nome(NM_MAE_PAC) else NA_character_,
    DT_NASC_date    = parse_data_segura(DT_NASC),
    DT_NOTIFIC_date = parse_data_segura(DT_NOTIFIC),
    SG_UF           = if (tem_SG_UF_dcc) SG_UF else NA_character_,
    CD_MN_RESI      = if (tem_CD_MN_RESI_dcc) CD_MN_RESI else NA_character_
  ) %>%
  dplyr::filter(!is.na(NM_PACIENT_norm), !is.na(DT_NASC_date))

dca <- dca_raw %>%
  dplyr::mutate(
    NM_PACIENT_norm = normaliza_nome(NM_PACIENT),
    NM_MAE_norm     = if (tem_NM_MAE_dca) normaliza_nome(NM_MAE_PAC) else NA_character_,
    DT_NASC_date    = parse_data_segura(DT_NASC),
    DT_NOTIFIC_date = parse_data_segura(DT_NOTIFIC),
    SG_UF           = if (tem_SG_UF_dca) SG_UF else NA_character_,
    ID_MN_RESI      = if (tem_ID_MN_RESI_dca) ID_MN_RESI else NA_character_
  ) %>%
  dplyr::filter(!is.na(NM_PACIENT_norm), !is.na(DT_NASC_date))

# --- 8) Seleção e renomeação (sufixos claros) ---
base_dcc_sel <- dcc %>%
  dplyr::select(
    NU_NOTIFIC, NM_PACIENT, NM_PACIENT_norm, NM_MAE_norm,
    DT_NASC, DT_NASC_date, DT_NOTIFIC, DT_NOTIFIC_date, SG_UF, CD_MN_RESI
  ) %>%
  dplyr::rename(
    NU_NOTIFIC_DCC      = NU_NOTIFIC,
    NM_PACIENT_DCC      = NM_PACIENT,
    NM_PACIENT_norm_DCC = NM_PACIENT_norm,
    NM_MAE_norm_DCC     = NM_MAE_norm,
    DT_NASC_DCC         = DT_NASC,
    DT_NASC_date_DCC    = DT_NASC_date,
    DT_NOTIFIC_DCC_raw  = DT_NOTIFIC,
    DT_NOTIFIC_date_DCC = DT_NOTIFIC_date,
    SG_UF_DCC           = SG_UF,
    CD_MN_RESI_DCC      = CD_MN_RESI
  )

base_dca_sel <- dca %>%
  dplyr::select(
    NU_NOTIFIC, NM_PACIENT, NM_PACIENT_norm, NM_MAE_norm,
    DT_NASC, DT_NASC_date, DT_NOTIFIC, DT_NOTIFIC_date, SG_UF, ID_MN_RESI
  ) %>%
  dplyr::rename(
    NU_NOTIFIC_DCA      = NU_NOTIFIC,
    NM_PACIENT_DCA      = NM_PACIENT,
    NM_PACIENT_norm_DCA = NM_PACIENT_norm,
    NM_MAE_norm_DCA     = NM_MAE_norm,
    DT_NASC_DCA         = DT_NASC,
    DT_NASC_date_DCA    = DT_NASC_date,
    DT_NOTIFIC_DCA_raw  = DT_NOTIFIC,
    DT_NOTIFIC_date_DCA = DT_NOTIFIC_date,
    SG_UF_DCA           = SG_UF,
    ID_MN_RESI_DCA      = ID_MN_RESI
  )

# --- 9) BLOQUEIO por DT_NASC (±1 dia) ---
# a) match exato
j_exato <- dplyr::inner_join(
  base_dcc_sel, base_dca_sel,
  by = c("DT_NASC_date_DCC" = "DT_NASC_date_DCA"),
  keep = TRUE, relationship = "many-to-many"
) %>% dplyr::mutate(DIFF_DIAS_DT_NASC = 0L)

# b) DCC +1 dia = DCA
j_plus1 <- base_dcc_sel %>%
  dplyr::mutate(DT_NASC_date_shift = DT_NASC_date_DCC + lubridate::days(1)) %>%
  dplyr::inner_join(
    base_dca_sel, by = c("DT_NASC_date_shift" = "DT_NASC_date_DCA"),
    keep = TRUE, relationship = "many-to-many"
  ) %>%
  dplyr::mutate(DIFF_DIAS_DT_NASC = 1L) %>%
  dplyr::select(-DT_NASC_date_shift)

# c) DCC −1 dia = DCA
j_minus1 <- base_dcc_sel %>%
  dplyr::mutate(DT_NASC_date_shift = DT_NASC_date_DCC - lubridate::days(1)) %>%
  dplyr::inner_join(
    base_dca_sel, by = c("DT_NASC_date_shift" = "DT_NASC_date_DCA"),
    keep = TRUE, relationship = "many-to-many"
  ) %>%
  dplyr::mutate(DIFF_DIAS_DT_NASC = -1L) %>%
  dplyr::select(-DT_NASC_date_shift)

candidatos_raw <- dplyr::bind_rows(j_exato, j_plus1, j_minus1) %>%
  dplyr::arrange(abs(DIFF_DIAS_DT_NASC)) %>%                   # prioriza match exato
  dplyr::distinct(NU_NOTIFIC_DCC, NU_NOTIFIC_DCA, .keep_all = TRUE)

# --- 10) Similaridade de nome (paciente + mãe) e filtro ---
candidatos <- candidatos_raw %>%
  dplyr::mutate(
    SIM_NOME = sim_jw(NM_PACIENT_norm_DCC, NM_PACIENT_norm_DCA),
    SIM_MAE  = sim_jw(NM_MAE_norm_DCC,     NM_MAE_norm_DCA)
  ) %>%
  dplyr::filter(!is.na(SIM_NOME) & SIM_NOME >= LIMIAR_SIMILARIDADE) %>%
  dplyr::filter(is.na(SIM_MAE) | SIM_MAE >= LIMIAR_SIMILARIDADE_MAE)

# --- 11) Resultado final (padding dos NUs, ordenação) ---
resultado <- candidatos %>%
  dplyr::transmute(
    NU_NOTIFIC_DCC = stringr::str_pad(as.character(NU_NOTIFIC_DCC), width = 14, pad = "0"),
    NU_NOTIFIC_DCA = stringr::str_pad(as.character(NU_NOTIFIC_DCA), width = 7,  pad = "0"),
    NM_PACIENT_DCC,
    NM_PACIENT_DCA,
    DT_NASC_DCC    = fmt_date(DT_NASC_date_DCC),
    DT_NASC_DCA    = fmt_date(DT_NASC_date_DCA),
    DIFF_DIAS_DT_NASC,  # -1, 0, +1 (sinal = DCC - DCA)
    DT_NOTIFIC_DCC = fmt_date(DT_NOTIFIC_date_DCC),
    DT_NOTIFIC_DCA = fmt_date(DT_NOTIFIC_date_DCA),
    SG_UF_DCC,
    CD_MN_RESI_DCC,     # DCC: código do município de residência
    SG_UF_DCA,
    ID_MN_RESI_DCA,     # DCA: ID do município de residência (mantido)
    SIMILARIDADE_NOME = round(SIM_NOME * 100, 2),
    SIMILARIDADE_MAE  = round(SIM_MAE  * 100, 2)
  ) %>%
  dplyr::arrange(dplyr::desc(SIMILARIDADE_NOME),
                 dplyr::desc(dplyr::coalesce(SIMILARIDADE_MAE, -1)),
                 DIFF_DIAS_DT_NASC, NU_NOTIFIC_DCC)

# --- 12) Exportação ---
# 12.1 XLSX com colunas NU_* como Texto
wb <- openxlsx::createWorkbook()
openxlsx::addWorksheet(wb, "DCC_vs_DCA")
openxlsx::writeData(wb, "DCC_vs_DCA", resultado)
if (nrow(resultado) > 0) {
  textStyle <- openxlsx::createStyle(numFmt = "@")  # formato Texto
  openxlsx::addStyle(
    wb, sheet = "DCC_vs_DCA", style = textStyle,
    rows = 2:(nrow(resultado) + 1), cols = c(1, 2), gridExpand = TRUE
  )
}
openxlsx::saveWorkbook(wb, arq_xlsx, overwrite = TRUE)

# 12.2 CSV com ; e BOM
# Se quiser garantir ; e BOM, usamos write_delim + BOM manual (como no Script 1):
tmp <- tempfile(fileext = ".csv")
readr::write_delim(resultado, tmp, delim = ";", na = "", quote = "all")
raw <- readBin(tmp, what = "raw", n = file.info(tmp)$size)
bom <- as.raw(c(0xEF, 0xBB, 0xBF))
writeBin(c(bom, raw), arq_csv)
unlink(tmp)

# --- 13) Log no console ---
message("Total DCC lidos: ", nrow(dcc_raw),
        " | Após preparo (nome e DT_NASC válidos): ", nrow(dcc))
message("Total DCA lidos: ", nrow(dca_raw),
        " | Após preparo (nome e DT_NASC válidos): ", nrow(dca))
message("Candidatos (match por DT_NASC ±1 dia): ", nrow(candidatos_raw))
message("Possíveis duplicatas (nome >= ", LIMIAR_SIMILARIDADE,
        " & mãe >= ", LIMIAR_SIMILARIDADE_MAE, " quando disponível): ", nrow(resultado))
message("Arquivos salvos em:",
        "\n- ", arq_xlsx,
        "\n- ", arq_csv)
